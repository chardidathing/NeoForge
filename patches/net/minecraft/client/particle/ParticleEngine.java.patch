--- a/net/minecraft/client/particle/ParticleEngine.java
+++ b/net/minecraft/client/particle/ParticleEngine.java
@@ -11,8 +_,6 @@
 import com.mojang.blaze3d.vertex.MeshData;
 import com.mojang.blaze3d.vertex.Tesselator;
 import com.mojang.logging.LogUtils;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import java.io.IOException;
 import java.io.Reader;
@@ -46,7 +_,6 @@
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.particles.ParticleType;
 import net.minecraft.core.particles.ParticleTypes;
-import net.minecraft.core.particles.SimpleParticleType;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.resources.FileToIdConverter;
 import net.minecraft.resources.ResourceLocation;
@@ -65,6 +_,7 @@
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.neoforged.api.distmarker.Dist;
 import net.neoforged.api.distmarker.OnlyIn;
+import net.neoforged.neoforge.client.renderer.IGraphicsShader;
 import org.slf4j.Logger;
 
 @OnlyIn(Dist.CLIENT)
@@ -77,11 +_,11 @@
         ParticleRenderType.TERRAIN_SHEET, ParticleRenderType.PARTICLE_SHEET_OPAQUE, ParticleRenderType.PARTICLE_SHEET_TRANSLUCENT, ParticleRenderType.CUSTOM
     );
     protected ClientLevel level;
-    private final Map<ParticleRenderType, Queue<Particle>> particles = Maps.newIdentityHashMap();
+    private final Map<ParticleRenderType, Queue<Particle>> particles = Maps.newTreeMap(net.neoforged.neoforge.client.ClientHooks.makeParticleRenderTypeComparator(RENDER_ORDER));
     private final Queue<TrackingEmitter> trackingEmitters = Queues.newArrayDeque();
     private final TextureManager textureManager;
     private final RandomSource random = RandomSource.create();
-    private final Int2ObjectMap<ParticleProvider<?>> providers = new Int2ObjectOpenHashMap<>();
+    private final Map<ResourceLocation, ParticleProvider<?>> providers = new java.util.HashMap<>();
     private final Queue<Particle> particlesToAdd = Queues.newArrayDeque();
     private final Map<ResourceLocation, ParticleEngine.MutableSpriteSet> spriteSets = Maps.newHashMap();
     private final TextureAtlas textureAtlas;
@@ -214,10 +_,14 @@
         this.register(ParticleTypes.BLOCK_CRUMBLE, new TerrainParticle.CrumblingProvider());
     }
 
+    /** @deprecated Register via {@link net.neoforged.neoforge.client.event.RegisterParticleProvidersEvent} */
+    @Deprecated
     public <T extends ParticleOptions> void register(ParticleType<T> p_107382_, ParticleProvider<T> p_107383_) {
-        this.providers.put(BuiltInRegistries.PARTICLE_TYPE.getId(p_107382_), p_107383_);
+        this.providers.put(BuiltInRegistries.PARTICLE_TYPE.getKey(p_107382_), p_107383_);
     }
 
+    /** @deprecated Register via {@link net.neoforged.neoforge.client.event.RegisterParticleProvidersEvent} */
+    @Deprecated
     public <T extends ParticleOptions> void register(ParticleType<T> p_273423_, ParticleProvider.Sprite<T> p_273134_) {
         this.register(
             p_273423_,
@@ -234,10 +_,12 @@
         );
     }
 
+    /** @deprecated Register via {@link net.neoforged.neoforge.client.event.RegisterParticleProvidersEvent} */
+    @Deprecated
     public <T extends ParticleOptions> void register(ParticleType<T> p_107379_, ParticleEngine.SpriteParticleRegistration<T> p_107380_) {
         ParticleEngine.MutableSpriteSet particleengine$mutablespriteset = new ParticleEngine.MutableSpriteSet();
         this.spriteSets.put(BuiltInRegistries.PARTICLE_TYPE.getKey(p_107379_), particleengine$mutablespriteset);
-        this.providers.put(BuiltInRegistries.PARTICLE_TYPE.getId(p_107379_), p_107380_.create(particleengine$mutablespriteset));
+        this.providers.put(BuiltInRegistries.PARTICLE_TYPE.getKey(p_107379_), p_107380_.create(particleengine$mutablespriteset));
     }
 
     @Override
@@ -357,7 +_,7 @@
     private <T extends ParticleOptions> Particle makeParticle(
         T p_107396_, double p_107397_, double p_107398_, double p_107399_, double p_107400_, double p_107401_, double p_107402_
     ) {
-        ParticleProvider<T> particleprovider = (ParticleProvider<T>)this.providers.get(BuiltInRegistries.PARTICLE_TYPE.getId(p_107396_.getType()));
+        ParticleProvider<T> particleprovider = (ParticleProvider<T>) this.providers.get(BuiltInRegistries.PARTICLE_TYPE.getKey(p_107396_.getType()));
         return particleprovider == null
             ? null
             : particleprovider.createParticle(p_107396_, this.level, p_107397_, p_107398_, p_107399_, p_107400_, p_107401_, p_107402_);
@@ -433,33 +_,25 @@
         }
     }
 
+    @Deprecated
     public void render(LightTexture p_107339_, Camera p_107340_, float p_107341_) {
+        render(p_107339_, p_107340_, p_107341_, null, type -> true);
+    }
+
+    public void render(LightTexture p_107339_, Camera p_107340_, float p_107341_, @Nullable net.minecraft.client.renderer.culling.Frustum frustum, java.util.function.Predicate<ParticleRenderType> renderTypePredicate) {
         p_107339_.turnOnLightLayer();
         RenderSystem.enableDepthTest();
+        //TODO porting: is this even needed with the particle render order fix???
+        RenderSystem.activeTexture(org.lwjgl.opengl.GL13.GL_TEXTURE2);
+        RenderSystem.activeTexture(org.lwjgl.opengl.GL13.GL_TEXTURE0);
 
-        for (ParticleRenderType particlerendertype : RENDER_ORDER) {
+        for (ParticleRenderType particlerendertype : this.particles.keySet()) { // Neo: allow custom IParticleRenderType's
+            if (particlerendertype == ParticleRenderType.NO_RENDER || !renderTypePredicate.test(particlerendertype)) continue;
             Queue<Particle> queue = this.particles.get(particlerendertype);
             if (queue != null && !queue.isEmpty()) {
-                Tesselator tesselator = Tesselator.getInstance();
-                BufferBuilder bufferbuilder = particlerendertype.begin(tesselator, this.textureManager);
-                if (bufferbuilder != null) {
-                    for (Particle particle : queue) {
-                        try {
-                            particle.render(bufferbuilder, p_107340_, p_107341_);
-                        } catch (Throwable throwable) {
-                            CrashReport crashreport = CrashReport.forThrowable(throwable, "Rendering Particle");
-                            CrashReportCategory crashreportcategory = crashreport.addCategory("Particle being rendered");
-                            crashreportcategory.setDetail("Particle", particle::toString);
-                            crashreportcategory.setDetail("Particle Type", particlerendertype::toString);
-                            throw new ReportedException(crashreport);
-                        }
-                    }
-
-                    MeshData meshdata = bufferbuilder.build();
-                    if (meshdata != null) {
-                        BufferUploader.drawWithShader(meshdata);
-                    }
-                }
+                net.neoforged.neoforge.client.ClientHooks.renderParticles(
+                        particlerendertype, queue, frustum, p_107340_, p_107341_
+                );
             }
         }
 
@@ -468,6 +_,35 @@
         p_107339_.turnOffLightLayer();
     }
 
+    public void renderParticlesWithType(final ParticleRenderType particleRenderType, final Iterable<Particle> toRender, @Nullable final net.minecraft.client.renderer.culling.Frustum clippingHelper, Camera p_107340_, float partialTickTime, java.util.function.Consumer<IGraphicsShader> afterSetupAction, java.util.function.Consumer<IGraphicsShader> postRenderAction) {
+        Tesselator tesselator = Tesselator.getInstance();
+        BufferBuilder bufferbuilder = particleRenderType.begin(tesselator, this.textureManager);
+
+        afterSetupAction.accept(RenderSystem.getShader());
+
+        if (bufferbuilder != null) {
+            for (Particle particle : toRender) {
+                if (clippingHelper != null && !clippingHelper.isVisible(particle.getRenderBoundingBox(partialTickTime))) continue;
+                try {
+                    particle.render(bufferbuilder, p_107340_, partialTickTime);
+                } catch (Throwable throwable) {
+                    CrashReport crashreport = CrashReport.forThrowable(throwable, "Rendering Particle");
+                    CrashReportCategory crashreportcategory = crashreport.addCategory("Particle being rendered");
+                    crashreportcategory.setDetail("Particle", particle::toString);
+                    crashreportcategory.setDetail("Particle Type", particleRenderType::toString);
+                    throw new ReportedException(crashreport);
+                }
+            }
+
+            MeshData meshdata = bufferbuilder.build();
+            if (meshdata != null) {
+                BufferUploader.drawWithShader(meshdata);
+            }
+        }
+
+        postRenderAction.accept(RenderSystem.getShader());
+    }
+
     public void setLevel(@Nullable ClientLevel p_107343_) {
         this.level = p_107343_;
         this.clearParticles();
@@ -475,7 +_,7 @@
     }
 
     public void destroy(BlockPos p_107356_, BlockState p_107357_) {
-        if (!p_107357_.isAir() && p_107357_.shouldSpawnTerrainParticles()) {
+        if (!p_107357_.isAir() && !net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions.of(p_107357_).addDestroyEffects(p_107357_, this.level, p_107356_, this)) {
             VoxelShape voxelshape = p_107357_.getShape(this.level, p_107356_);
             double d0 = 0.25;
             voxelshape.forAllBoxes(
@@ -507,7 +_,7 @@
                                         d6 - 0.5,
                                         p_107357_,
                                         p_107356_
-                                    )
+                                    ).updateSprite(p_107357_, p_107356_)
                                 );
                             }
                         }
@@ -552,12 +_,28 @@
                 d0 = (double)i + aabb.maxX + 0.1F;
             }
 
-            this.add(new TerrainParticle(this.level, d0, d1, d2, 0.0, 0.0, 0.0, blockstate, p_107368_).setPower(0.2F).scale(0.6F));
+            this.add((new TerrainParticle(this.level, d0, d1, d2, 0.0D, 0.0D, 0.0D, blockstate, p_107368_).updateSprite(blockstate, p_107368_)).setPower(0.2F).scale(0.6F));
         }
     }
 
     public String countParticles() {
         return String.valueOf(this.particles.values().stream().mapToInt(Collection::size).sum());
+    }
+
+    public void iterateParticles(java.util.function.Consumer<Particle> consumer) {
+        for (ParticleRenderType particlerendertype : this.particles.keySet()) {
+            if (particlerendertype == ParticleRenderType.NO_RENDER) continue;
+            Iterable<Particle> iterable = this.particles.get(particlerendertype);
+            if (iterable != null) {
+                iterable.forEach(consumer);
+            }
+        }
+    }
+
+    public void addBlockHitEffects(BlockPos pos, net.minecraft.world.phys.BlockHitResult target) {
+        BlockState state = level.getBlockState(pos);
+        if (!net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions.of(state).addHitEffects(state, level, target, this))
+            crack(pos, target.getDirection());
     }
 
     private boolean hasSpaceInParticleLimit(ParticleGroup p_172280_) {
